"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs_1 = require("fs");
const utils_1 = require("../utils");
const manifest = require('../../package.json');
exports.hooks = [
    'pre-commit',
    'commit-msg',
    'pre-push',
];
exports.customHookTpl = `#!/usr/bin/env bash
set -e
node %s $*`;
exports.writeIntoHookTpl = `
# created by ${manifest.name}
PATH="$PATH:/usr/local/bin"
if [ -f $HOME/.nvm/nvm.sh ]
then
  . $HOME/.nvm/nvm.sh
  PATH="$PATH:$HOME/.nvm/versions/node/$(nvm current)/bin"
fi
gitFlowHook="%s"
if [ -x "$gitFlowHook" ]; then 
  $gitFlowHook $*
fi
# created by ${manifest.name}`;
exports.writeIntoHookRegExp = new RegExp(`\n# created by ${manifest.name}[\\s\\S]*# created by ${manifest.name}`, 'g');
exports.writeNewHookTpl = `#!/usr/bin/env bash
set -e
${exports.writeIntoHookTpl}
`;
async function getGitFolderPath() {
    let topLevelPath = process.cwd();
    try {
        topLevelPath = await utils_1.getGitTopLevelPath();
    }
    catch (err) {
        utils_1.logger.error('exec git failed, please check:');
        utils_1.logger.error('1. git is installed?');
        utils_1.logger.error(`2. ${topLevelPath} is a git repository?`);
        return null;
    }
    const gitFolderPath = path.resolve(topLevelPath, '.git');
    try {
        try {
            await utils_1.fsAsync.access(gitFolderPath, fs_1.constants.W_OK);
        }
        catch (err) {
            throw new Error(`${gitFolderPath} cann't be access by write mode`);
        }
        const stat = await utils_1.fsAsync.lstat(gitFolderPath);
        if (!stat.isDirectory()) {
            throw new Error(`${gitFolderPath} is not a directory`);
        }
    }
    catch (err) {
        utils_1.logger.error('check .git failed, caused by:');
        utils_1.logger.error(err);
        return null;
    }
    return gitFolderPath;
}
exports.getGitFolderPath = getGitFolderPath;
